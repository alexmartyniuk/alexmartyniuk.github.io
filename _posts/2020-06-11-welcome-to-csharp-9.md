---
layout: post
title:  "Зустрічайте C# 9.0"
date:   2020-05-28 19:00:00 +0200
date_friendly: 28 травня 2020 р. 
published: false
categories: [Програмування, dotNET]
tags: [dotnet, csharp, translation]
---

Це переклад статті ["Welcome to C# 9.0"](https://devblogs.microsoft.com/dotnet/welcome-to-c-9-0/) Мадса Торгерсена - працівника Microsoft і головного дизайнера мови C#.

C# 9.0 набуває форм і я хочу поділитись нашим баченням найбільш важливих можливостей, які ми додаємо в наступну версію цієї мови.

З кожною новою версією ми прагнемо зробити мову більш ясною і простою для більшості сценаріїв використання і C# 9.0 не є винятком. Одним з фокусів цього разу є забезпечення лаконічності в представленні даних та підтримка механізмів їх незмінності.

Що ж, поїхали!


## Властивості лише для ініціалізації

Ініціалізатори об'єктів просто чудові. Вони дають програмісту дуже гнучку і, водночас, легко читаєму форму створення об'єктів. Вони особливо зручні для створення вкладених об'єктів, коли ціла ієрархія об'єктів створюється однією командою. Ось приклад:

```c#
new Person
{
    FirstName = "Scott",
    LastName = "Hunter"
}
```

Ініціалізатори об'єктів також звільняють автора класу від написання шаблонного коду конструкторів. Все, що потрібно - лише створити властивості!

```c#
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
```

Проте сьогодні тут є одне велике обмеження: щоб ініціалізатори працювали, властивості повинні бути такими, що змінюються (mutable). Вони функціонують завдяки виклику конструктора (без параметрів в даному випадку) і наступному присвоєнню значень через виклик сеттера.

Властивості p ініціалізацією виправлять це! Вони визначають `init` аксессор який дуже схожий на `set` аксессор, але може викликатись лише під час ініціалізації:  

```c#
public class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

З таким підходом код написаний вище все ще коректний, але всі наступні присвоєння значень властивостям `FirstName` і `LastName` будуть помилкою.

## Init аксессори та поля лише для читання

Because init accessors can only be called during initialization, they are allowed to mutate readonly fields of the enclosing class, just like you can in a constructor.

Так як init аксессори можуть викликатись лише під час ініціалізації, їм дозволено змінювати поля лише для читання того ж класу, точно так як ви можете зробити це у конструкторі.

```c#
public class Person
{
    private readonly string firstName;
    private readonly string lastName;
    
    public string FirstName 
    { 
        get => firstName; 
        init => firstName = (value ?? throw new ArgumentNullException(nameof(FirstName)));
    }
    public string LastName 
    { 
        get => lastName; 
        init => lastName = (value ?? throw new ArgumentNullException(nameof(LastName)));
    }
}
```

## Записи

Властивості з ініціалізацією чудово підходять, якщо ви хочете зробити певну властивість об'єкту незмінною. Якщо ж ви хочете зробити незмінним весь об'єкт, щоб він поводився як екземпляр типу-значення, вам необхідно визначити його як запис: 

```c#
public data class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

Ключове слово `data` у визначенні класу позначає клас як запис. Це додає йому певної поведінки як у типу-значення, яку ми розглянемо далі. Загалом, записи краще розглядати як "значення" (дані), а не як об'єкти. Вони не створені, щоб мати стан, який можливо змінити. Натомість, ви виражаєте зміни у часі, створюючи нові записи, що відображають новий стан. Їх однаковість визначається їх вмістом.

## Вираз with
When working with immutable data, a common pattern is to create new values from existing ones to represent a new state. For instance, if our person were to change their last name we would represent it as a new object that’s a copy of the old one, except with a different last name. This technique is often referred to as non-destructive mutation. Instead of representing the person over time, the record represents the person’s state at a given time.

To help with this style of programming, records allow for a new kind of expression; the with-expression:

При роботі з незмінними даними, загальний підхід - це створення копії для відображення нового стану. Для прикладу, якщо наша особа захоче змінити своє прізвище, ми реалізуємо це через створення нового об'єкту, що буде копією старого окрім різниці у прізвищі. Цю техніку часто називають неруйнівною мутацією. Замість того, щоб змінювати особу з часом запис відображає стан особи в конкретний момент часу.  

Щоб програмувати в такому стилі було легше, записи підтримують новий тип виразу - `with`:

```c#
var otherPerson = person with { LastName = "Hanselman" };
```

With вирази використовують синтаксис ініціалізаторів, щоб визначити чим будуть відрізнятись новий і старий об'єкти. Ви можете задати декілька властивостей.

Запис неявно включає захищений "конструктор копіювання" - це конструктор, який бере існуючий об'єкт запису і копіює його поля одне за одним в новий об'єкт:

```c#
protected Person(Person original) { /* copy all the fields */ } // generated
```

Вираз with викликає конструктор копіювання і потім застосовує ініціалізатор для визначених властивостей, але вже до проініціалізованих даних.

Якщо вас не влаштовує згенерований конструктор копіювання, ви можете визначити свій власний і він так само буде підхоплений виразом with. 

## Порівняння за значенням
Всі об'єкти наслідують віртуальний метод `Equals(object)` від класу object. Він є основою для статичного методу `Object.Equals(object, object)` коли обидва параметри не дорівнюють null.

Структури перевизначають його, щоб отримати "порівняння за значенням", це коли поля структури порівнюються рекурсивно через виклик Equals. Записи роблять так само.

Це означає те, що згідно з їх "значимістю", два об'єкти-записи можуть бути рівними, будучи різними екземплярами одного типу. Для прикладу, якщо ми повернемо назад прізвище у раніше зміненої особи:  

```c#
var originalPerson = otherPerson with { LastName = "Hunter" };
```

Тепер ми би мали `ReferenceEquals(person, originalPerson) = false` (це різні екземпляри), але `Equals(person, originalPerson) = true` (вони містять однакові дані).

Якщо вам не підходить порівняння по полям, що визначається за умовчанням, ви можете написати своє. Але треба бути обережним і розуміти, як працює порівняння за значеннями в структурах, особливо якщо використовується наслідування (до якого ми ще повернемося нижче).   

Поряд з перевизначенням `Equals` перевизначається також `GetHashCode()`, так як вони працюють у парі.

## Поля записів
Записи задумувались незмінюваними і такими, що містять лише публічніні властивості з ініціалізаторами. Записи можуть змінюватись в не деструктивний спосіб завдяки with-виразам. Для того, щоб спростити визначення записів для цього поширеного застосування синтаксис запису змінює значення `string FirstName `. Замість неявного приватного поля, як це було б у визначенні класу чи структури, в синтаксисі запису це означає публічну авто-властивість з ініціалізатором! Таким чином, визначення:   

```c#
public data class Person { string FirstName; string LastName; }
```

Означає в точності те ж, що ми мали раніше:

```c#
public data class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```
Ми вважаємо, це дозволяє зробити визначення запису чистим і красивим. Якщо вам дійсно потрібне приватне поле, ви завжди можете додати модифікатор `private`явно:

```c#
private string firstName;
```

## Позиційні записи
Інколи зручно використовувати більш позиційний підхід до записів, при якому їх вміст передається через аргументи конструктора і може бути отриманий назад завдяки позиційному деконструюванню.

Абсолютно нормальним є визначення власного конструктора і деконструктора запису:

```c#
public data class Person 
{ 
    string FirstName; 
    string LastName; 
    public Person(string firstName, string lastName) 
      => (FirstName, LastName) = (firstName, lastName);
    public void Deconstruct(out string firstName, out string lastName) 
      => (firstName, lastName) = (FirstName, LastName);
}
```

Але існує набагато коротший синтаксис для вираження того самого (зверніть увагу на регістр імен параметрів):

```c#
public data class Person(string FirstName, string LastName);
```

Цей запис визначає публічні авто-властивості і конструктор з деконструктором, тож ви можете написати:

```c#
var person = new Person("Scott", "Hunter"); // позиціне конструювання
var (f, l) = person;                        // позиціне деконструювання
```

Якщо вам не подобається згенерована авто-властивіть, ви можете визначити натомість свою власну з тими ж іменем, і згенеровані конструктор і деконструктор будуть її використовувати.

## Записис і мутація

Семантика значення не дуже добре поєднується зі змінюваним станом. Уявіть, ми помістили об'єкт запису в словник. Його наступне знаходження залежить від Equals та (інколи) GethashCode. Але, якщо запис змінює свій стан, він також змінює свою еквівалентність! Ми можемо не знайти його знову! В реалізації хеш таблиці це може пошкодити структуру даних, так як розміщення об'єкту грунтується на хеш коді, який він має в момент запису у таблицю.

Напевно, є допустимі приклади використання змінюваного стану записів, зокрема для кешування. Але ручна робота, необхідна для того, щоб перевизначити поведінку так, щоб ігнорувати цей стан, імовірно, буде досить значною.

# With-вираз та наслідування
Порівняння за значенням та не деструктивна мутація значно ускладнюються, коли поєднуються з наслідуванням. Давайте додамо похідний клас-запис до hfysit розглянутого прикладу:  

```c#
public data class Person { string FirstName; string LastName; }
public data class Student : Person { int ID; }
```

Почнемо наш приклад with-виразу зі створення екземпляру Student, але збережемо його у змінній типу Person:

```c#
Person person = new Student { FirstName = "Scott", LastName = "Hunter", ID = GetNewId() };
otherPerson = person with { LastName = "Hanselman" };
```

В останньому рядку з with-виразом компілятор не знає, що person фактично містить екземпляр Student. Тим не менш, новий екземпляр person не був би коректною копією, якби він не був екземпляром Student і не містив той самий ID, що і оригінальний об'єкт. 

C# робить це за нас. Записи містять прихований віртуальний метод, якому доручено клонування цілого об'єкту. Кожен похідний тип запису перевизначає цей метод і викликає конструктор копіювання для цього типу. Цей конструктор викликає аналогічний конструктор копіювання базового типу. With-вираз просто викликає прихований "clone" метод і застосовує ініціалізатор об'єкту до результату.

## Порівняння за значенням і наслідування

Подібно до реалізації with-виразів, порівняння за значенням також повинно бути "віртуальним" в тому значенні, що для порівняння двох екземплярів типу `Student` повинні бути порівняні всі поля типу `Student`, навіть якщо тип об'єкту на момент порівняння - це базовий тип, наприклад `Person`. Цього легко досягти перевизначивши метод `Equals`, що наразі вже є віртуальним.

Проте, є ще одна проблема з еквівалентністю. Що, як ви порівнюєте два різних підтипи базового типу Person? Ми не можемо дозволити вибирати тип, чий метод Equal використовувати: еквівалентність повинна бути симетричною. То ж результат не повинен залежати від порядку об'єктів. Іншими словами, вони повинні самі розібратись, чию еквівалентність застосовувати.    

Цей приклад ілюструє проблему:

```c#
Person person1 = new Person { FirstName = "Scott", LastName = "Hunter" };
Person person2 = new Student { FirstName = "Scott", LastName = "Hunter", ID = GetNewId() };
```

Чи рівні ці два об'єкти? `person1` може думати, що так, адже `person2` має всі поля типу `Person`, до того ж вони рівні. Але `person2` з цим не погодиться! Ми повинні бути впевненими, що вони обоє розуміють, що вони все ж різні об'єкти. 

І знову, C# подбав про це. Спосіб, в який це реалізовано такий, що записи мають віртуальну захищену властивість `EqualityContract`. Кожен похідний запис перевизначає її і для того, щоб два записи були однаковими вони повинні мати один і той самий `EqualityContract`.

## Програми на найвищому рівні

Написання простої програми на C# вимагає значної кількості шаблонного коду:

```c#
using System;
class Program
{
    static void Main()
    {
        Console.WriteLine("Hello World!");
    }
}
```

Це не тільки важко сприйняти тим, хто починає вивчати мову, а ще й захаращує код та додає зайві рівні відступів.

В C# 9.0 ви можете натомість просто писати вашу програму на найвищому рівні:

```c#
using System;

Console.WriteLine("Hello World!");
```

Будь які вирази дозволені. Програма може початися після списку `using` і перед будь яким типом чи простором імен. Ви можете так робити тільки в одному файлі, точно так як зараз ви можете мати лише один метод `Main`. 

Якщо ви хочете повернути код статусу, ви можете це зробити. Якщо ви хочете очікувати задачу з `await`, ви можете це зробити. І якщо ви хочете отримати доступ до аргументів командного рядку, вони доступні як "магічний" параметр `args`.

Локальні функції - це також вирази і вони так само дозволені на найвищому рівні. Але, у разі виклику їх поза областю програми найвищого рівня, буде помилка.

## Вдосконалене порівняння за зразком
Декілька нових типів шаблонів порівняння були додані в C# 9.0. Давайте подивимось на них в контексті цього фрагменту коду з навчального посібника: 

```c#
public static decimal CalculateToll(object vehicle) =>
    vehicle switch
    {
       ...
       
        DeliveryTruck t when t.GrossWeightClass > 5000 => 10.00m + 5.00m,
        DeliveryTruck t when t.GrossWeightClass < 3000 => 10.00m - 2.00m,
        DeliveryTruck _ => 10.00m,

        _ => throw new ArgumentException("Not a known vehicle type", nameof(vehicle))
    };
```
### Спрощений шаблон типу

Наразі, шаблон типу вимагає визначення змінної коли, навіть коли ця змінна ігнорується, як у випадку з `_`. У прикладі вище це `DeliveryTruck _`. Але тепер ви можете просто написати тип:

```c#
DeliveryTruck => 10.00m,
```

### Шаблони порівняння

C# 9.0 вводить шаблони на основі операторів порівняння <, <= і т.ін. Тож тепер ви можете написати чатину з DeliveryTruck з наведеного вище шаблону як вкладений switch вираз: 

```c#
DeliveryTruck t when t.GrossWeightClass switch
{
    > 5000 => 10.00m + 5.00m,
    < 3000 => 10.00m - 2.00m,
    _ => 10.00m,
},
```
Тут `> 5000` і `< 3000` - це шаблони порівняння.

## Логічні шаблони

Нарешті ви можете поєднувати шаблони з логічними операторами `and`, `or` і `not`, записаними словами, щоб уникнути плутанини з операторами, що використовуються у виразах. Для прикладу, випадок з вкладеним switch виразом вище можна переписати розташувавши діапазони по зростанню, як нижче:

```c#
DeliveryTruck t when t.GrossWeightClass switch
{
    < 3000 => 10.00m - 2.00m,
    >= 3000 and <= 5000 => 10.00m,
    > 5000 => 10.00m + 5.00m,
},
```
Середній вираз тут використовує `and`, щоб поєднати два шаблони порівняння в шаблон, що відображає діапазон. 

Шаблон `not` може використовуватись спільно з констатним шаблоном `null`, як `not null`. Для прикладу, ми можемо розділити обробку невідомого випадку в залежності від того, чи дорівнює він `null`:

```c#
not null => throw new ArgumentException($"Not a known vehicle type: {vehicle}", nameof(vehicle)),
null => throw new ArgumentNullException(nameof(vehicle))
```

Також `not` може бути корисним з оператором if, умова якого містить вираз `is` замість потворних подвійних дужок:

```c#
if (!(e is Customer)) { ... }
```

Ви можете просто сказати

```c#
if (e is not Customer) { ... }
```

Improved target typing
## Вдосконалене приведення до цільового типу

"Приведенням до цільового типу" ми називаємо ситуацію, коли вираз отримує свій тип з контексту, в якому він використовується. Для прикладу `null` чи лямбда-вирази завжди використовують приведення до цільового типу.

В C# 9.0 деякі вирази, які до цього не використовували приведення до цільового типу, отримали можливість визначати його з контексту.

### Приведення до цільового типу у виразі `new`

Вираз `new` у C# завжди вимагав вказування типу (за винятком неявно типізованих масивів). Тепер ви можете пропустити тип, якщо змінна якій присвоюється вираз має чітко визначений тип. 

```c#
Point p = new (3, 5);
```

### Приведення до цільового типу у виразах `??` та `?:`

Інколи, умовні вирази `??` та `?:` не мають явного спільного типу між варіантами виконання. Такі випадки зараз не компілюються, але C# 9.0 буде дозволяти їх, якщо існує цільовий типу, до якого обидва результати можуть бути конвертовані.

```c#
Person person = student ?? customer; // Shared base type
int? result = b ? 0 : null; // nullable value type
```

## Коваріативні результати

Інколи корисно якось виразити те, що перевизначений метод похідного класу повертає більш конкретний тип, ніж визначено у базовому класі. C# 9.0 дозволяє таке:

```c#
abstract class Animal
{
    public abstract Food GetFood();
    ...
}
class Tiger : Animal
{
    public override Meat GetFood() => ...;
}
```

## І навіть більше…

Найкраще місце, щоб ознайомитися з повним переліком майбутніх можливостей в C# 9.0 і слідкувати за їх реалізацією - це сторінка Статус Можливостей Мови в репозиnорії Roslyn (C#/VB Compiler) на GitHub.

Приємного кодування!

