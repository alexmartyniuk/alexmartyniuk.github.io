---
layout: post
title:  "Зустрічайте C# 9.0"
date:   2020-05-28 19:00:00 +0200
date_friendly: 28 травня 2020 р. 
published: true
categories: [Програмування, dotNET]
tags: [dotnet, csharp, translation]
---

Це переклад статті ["Welcome to C# 9.0"](https://devblogs.microsoft.com/dotnet/welcome-to-c-9-0/) Медса Тоерсена - працівника Microsoft і головного дизайнера мови C#.

C# 9.0 набуває форм і я хочу поділитись нашим баченням найбільш важливих можливостей, які ми додаємо в наступну версію цієї мови.

З кожною новою версією ми прагнемо зробити мову більш ясною і простою для загальних сценаріїв використання і C# 9.0 не є винятком. Одним з фокусів цього разу є забезпечення лаконічності в представленні даних та підтримка механізмів їх незмінності.

Що ж, поїхали!

## Властивості з ініціалізацією

Ініціалізатори об'єктів надзвичайно корисні. Вони дають програмісту дуже гнучку і, водночас, легко зрозумілу форму створення об'єктів. Вони особливо зручні для створення вкладених об'єктів, коли ціла ієрархія створюється однією командою. Ось приклад:

```c#
new Person
{
    FirstName = "Scott",
    LastName = "Hunter"
}
```

Ініціалізатори об'єктів також звільняють автора класу від написання шаблонного коду конструкторів. Все, що потрібно, - лише створити певні властивості!

```c#
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}
```

Проте сьогодні є одне велике обмеження: щоб ініціалізатори працювали, властивості повинні бути *змінюваними* (mutable). Вони працюють завдяки виклику конструктора (без параметрів в даному випадку) і наступному присвоєнню значень через виклик сеттерів властивостей.

Властивості з ініціалізацією виправлять це! Вони визначають `init` аксессор який дуже схожий на `set` аксессор, але може викликатись лише під час ініціалізації об'єкту:  

```c#
public class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

З таким підходом код написаний вище все ще коректний, але всі наступні присвоєння значень властивостям `FirstName` і `LastName` викличуть помилку.

### Init аксессори та поля лише для читання

Так як `init` аксессори можуть викликатись лише під час ініціалізації, їм дозволено змінювати поля для читання того ж класу, точно так як ви зараз можете зробити це у конструкторі.

```c#
public class Person
{
    private readonly string firstName;
    private readonly string lastName;
    
    public string FirstName 
    { 
        get => firstName; 
        init => firstName = (value ?? throw new ArgumentNullException(nameof(FirstName)));
    }
    public string LastName 
    { 
        get => lastName; 
        init => lastName = (value ?? throw new ArgumentNullException(nameof(LastName)));
    }
}
```

## Записи

Властивості з ініціалізацією чудово підходять, якщо ви хочете зробити певну властивість об'єкту незмінною. Якщо ж ви хочете зробити незмінним весь об'єкт, щоб він поводив себе як екземпляр типу-значення, вам необхідно визначити його як *запис*: 

```c#
public data class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```

Ключове слово `data` у визначенні класу позначає клас як запис. Це додає йому певної поведінки характерної для типу-значення, яку ми розглянемо далі. Загалом, записи краще розглядати як "значення" (дані), а не як об'єкти. Вони не створені, щоб мати змінюваний стан. Натомість, ви виражаєте зміни у часі, створюючи нові записи, що відображають новий стан. Вони визначаються не унікальністю посилання, а тотожністю вмісту.

### Вираз with
При роботі з незмінними даними, загальний підхід полягає у створенні копії для відображення нового стану об'єкту. Для прикладу, якщо наша особа захоче змінити своє прізвище, ми реалізуємо це через створення нового об'єкту, що буде копією старого окрім іншого прізвища. Цю техніку часто називають *неруйнівною мутацією*. Замість того, щоб змінювати особу *з часом* запис відображає стан особи в *конкретний момент часу*.  

Щоб програмувати в такому стилі було легше, записи підтримують новий тип виразу - `with`:

```c#
var otherPerson = person with { LastName = "Hanselman" };
```

With-вирази використовують синтаксис ініціалізаторів, щоб визначити чим будуть відрізнятись новий і старий об'єкти. Ви можете задати відразу декілька властивостей.

Запис неявно включає захищений "конструктор копіювання" - це конструктор, який бере об'єкт запису, що існує, і копіює його поля одне за одним в новий об'єкт:

```c#
protected Person(Person original) { /* копіює всі поля */ } // автозгенерований
```

Вираз `with` викликає конструктор копіювання і потім застосовує ініціалізатор для перевизначених властивостей, але вже до проініціалізованих раніше даних.

Якщо вас не влаштовує згенерований конструктор копіювання, ви можете визначити свій власний і він так само буде використовуватись виразом `with`. 

### Порівняння за значенням
Всі об'єкти наслідують віртуальний метод `Equals(object)` від класу `object`. Він є основою для роботи статичного методу `Object.Equals(object, object)` коли обидва параметри не дорівнюють `null`.

Структури перевизначають його, щоб отримати "порівняння за значенням". Це коли поля структури порівнюються рекурсивно через виклик `Equals`. Записи роблять так само.

Це означає те, що згідно з їх "значимістю", два об'єкти-записи можуть бути рівними, будучи *різними* екземплярами одного типу. Для прикладу, якщо ми повернемо назад прізвище у раніше зміненої особи:  

```c#
var originalPerson = otherPerson with { LastName = "Hunter" };
```

Тепер ми би мали `ReferenceEquals(person, originalPerson)` = false (це різні екземпляри), але `Equals(person, originalPerson)` = true (вони містять однакові дані).

Якщо вам не підходить порівняння по полям, що визначається за умовчанням, ви можете написати своє. Але треба бути обережним і розуміти, як працює порівняння за значеннями в структурах, особливо якщо є наслідування (до якого ми ще повернемося нижче).   

Поряд з перевизначенням `Equals` перевизначається також `GetHashCode()`, так як вони працюють у парі.

### Поля записів
Записи задумувались незмінюваними і такими, що містять лише публічні властивості з ініціалізаторами. Записи можуть змінюватись в не деструктивний спосіб завдяки `with`-виразам. Для того, щоб спростити визначення записів для цього поширеного випадку, синтаксис запису змінює значення, що несе `string FirstName`. Замість неявного приватного поля, як це було б у визначенні класу чи структури, в синтаксисі запису це означає публічну авто-властивість з ініціалізатором! Таким чином, визначення:   

```c#
public data class Person { string FirstName; string LastName; }
```
Означає в точності те ж, що ми мали раніше:

```c#
public data class Person
{
    public string FirstName { get; init; }
    public string LastName { get; init; }
}
```
Ми вважаємо, це дозволяє зробити визначення запису чистим і красивим. Якщо вам дійсно потрібне приватне поле, ви завжди можете додати модифікатор `private`явно:

```c#
private string firstName;
```

### Позиційні записи
Інколи зручно використовувати більш позиційний підхід до записів, при якому дані передаються через аргументи конструктора і можуть бути отримані назад завдяки позиційному деконструюванню.

Абсолютно допустимим є визначення власного конструктора і деконструктора запису:

```c#
public data class Person 
{ 
    string FirstName; 
    string LastName; 
    public Person(string firstName, string lastName) 
      => (FirstName, LastName) = (firstName, lastName);
    public void Deconstruct(out string firstName, out string lastName) 
      => (firstName, lastName) = (FirstName, LastName);
}
```

Але існує набагато коротший синтаксис для вираження того самого (зверніть увагу на регістр імен параметрів):

```c#
public data class Person(string FirstName, string LastName);
```

Цей запис визначає публічні авто-властивості і конструктор з деконструктором, тож ви можете написати:

```c#
var person = new Person("Scott", "Hunter"); // позиціне конструювання
var (f, l) = person;                        // позиціне деконструювання
```

Якщо вам не подобається згенерована авто-властивіть, ви можете натомість визначити свою власну з тим же іменем, і згенеровані конструктор та деконструктор будуть її використовувати.

### Записис і мутація
Семантика значення не дуже добре поєднується зі змінюваним станом. Уявіть, ми помістили об'єкт запису в словник. Його подальший пошук залежить від `Equals` та (інколи) `GethashCode`. Але, якщо запис змінює свій стан, він також змінює свою еквівалентність! Ми можемо не знайти його знову! В реалізації хеш таблиці це може пошкодити структуру даних, так як розміщення об'єкту грунтується на хеш коді, який він має в момент запису у таблицю.

Напевно, є допустимі приклади використання змінюваного стану записів, зокрема для кешування. Але ручна робота, необхідна для того, щоб перевизначити поведінку так, щоб ігнорувати цей стан, імовірно, буде досить значною.

### With-вираз та наслідування
Порівняння за значенням та недеструктивна мутація значно ускладнюються, коли поєднуються з наслідуванням. Давайте додамо похідний клас-запис `Student` до раніше розглянутого прикладу:  

```c#
public data class Person { string FirstName; string LastName; }
public data class Student : Person { int ID; }
```

Почнемо наш приклад зі створення екземпляру `Student`, але збережемо його у змінній типу `Person`:

```c#
Person person = new Student { FirstName = "Scott", LastName = "Hunter", ID = GetNewId() };
otherPerson = person with { LastName = "Hanselman" };
```

В останньому рядку з `with`-виразом компілятор не знає, що `person` фактично містить екземпляр `Student`. Тим не менш, новий екземпляр `otherPerson` не був би коректною копією, якби він *не був екземпляром* `Student` і не містив той самий `ID`, що і оригінальний об'єкт. 

C# робить це за нас. Записи містять прихований віртуальний метод, якому доручено клонування *цілого* об'єкту. Кожен похідний тип запису перевизначає цей метод і викликає конструктор копіювання для цього типу. Цей конструктор викликає аналогічний конструктор базового типу. `With`-вираз просто викликає це прихований метод клонування і застосовує ініціалізатор об'єкту до результату.

### Порівняння за значенням і наслідування
Подібно до реалізації `with`-виразів, порівняння за значенням також повинно бути "віртуальним" в тому значенні, що для порівняння двох екземплярів типу `Student` повинні бути порівняні всі поля типу `Student`, навіть якщо тип посилання на момент порівняння - це базовий тип, наприклад `Person`. Цього легко досягти перевизначивши метод `Equals`, що наразі вже є віртуальним.

Проте, є ще одна проблема з еквівалентністю. Що, як ви порівнюєте два *різних* підтипи базового типу `Person`? Ми не можемо дозволити вибирати метод `Equal` якого типу використовувати: еквівалентність повинна бути симетричною. То ж результат не повинен залежати від порядку об'єктів. Іншими словами, вони повинні самі *узгодити*, чию еквівалентність застосовувати.    

Цей приклад ілюструє проблему:

```c#
Person person1 = new Person { FirstName = "Scott", LastName = "Hunter" };
Person person2 = new Student { FirstName = "Scott", LastName = "Hunter", ID = GetNewId() };
```

Чи рівні ці два об'єкти? `person1` може думати, що так, адже `person2` має всі поля типу `Person` з тими ж значеннями. Але `person2` з цим не погодиться! Ми повинні бути впевненими, що вони обоє розуміють, що вони все ж різні об'єкти. 

І знову, C# подбав про це. Спосіб, в який це реалізовано: записи мають віртуальну захищену властивість `EqualityContract`. Кожен похідний запис перевизначає її і для того, щоб два записи були однаковими вони повинні мати один і той самий `EqualityContract`.

## Програми найвищого рівні
Написання простої програми на C# вимагає значної кількості шаблонного коду:

```c#
using System;
class Program
{
    static void Main()
    {
        Console.WriteLine("Hello World!");
    }
}
```

Це не тільки важко сприймати тим, хто тільки починає вивчати мову, а ще й захаращує код та додає зайві рівні відступів.

В C# 9.0 натомість ви можете просто писати вашу програму на найвищому рівні:

```c#
using System;

Console.WriteLine("Hello World!");
```

Будь які вирази дозволені. Програма може початися відразу після списку `using` і перед визначенням будь якого типу чи простору імен. Але ви можете так робити тільки в одному файлі, точно так як зараз ви можете мати лише один метод `Main`. 

Якщо ви хочете повернути код статусу, ви можете це зробити. Якщо ви хочете очікувати задачу з `await`, ви можете це зробити. І якщо ви хочете отримати доступ до аргументів командного рядку, вони доступні як "магічний" параметр `args`.

Локальні функції - це також вирази і вони так само дозволені на найвищому рівні. Але, у разі виклику їх поза областю програми найвищого рівня, буде згенеровано помилку.

## Вдосконалене порівняння за зразком
Декілька нових типів шаблонів порівняння були додані в C# 9.0. Давайте подивимось на них в контексті цього фрагменту коду з [навчального посібника](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/pattern-matching): 

```c#
public static decimal CalculateToll(object vehicle) =>
    vehicle switch
    {
       ...
       
        DeliveryTruck t when t.GrossWeightClass > 5000 => 10.00m + 5.00m,
        DeliveryTruck t when t.GrossWeightClass < 3000 => 10.00m - 2.00m,
        DeliveryTruck _ => 10.00m,

        _ => throw new ArgumentException("Not a known vehicle type", nameof(vehicle))
    };
```

### Спрощений шаблон типу
Наразі, шаблон типу вимагає визначення змінної, навіть якщо ця змінна ігнорується, як у випадку з `_`. У прикладі вище це `DeliveryTruck _`. Але тепер ви можете просто написати тип:

```c#
DeliveryTruck => 10.00m,
```

### Шаблони порівняння
C# 9.0 вводить шаблони на основі операторів порівняння `<`, `<=` і т.ін. Тож тепер ви можете написати чатину з `DeliveryTruck` з наведеного вище шаблону як вкладений switch вираз: 

```c#
DeliveryTruck t when t.GrossWeightClass switch
{
    > 5000 => 10.00m + 5.00m,
    < 3000 => 10.00m - 2.00m,
    _ => 10.00m,
},
```
Тут `> 5000` і `< 3000` - це шаблони порівняння.

### Логічні шаблони
Нарешті ви можете поєднувати шаблони з логічними операторами `and`, `or` і `not`. Вони записані словами, щоб уникнути плутанини з операторами у виразах. Для прикладу, випадок з вкладеним switch виразом вище можна переписати розташувавши діапазони по зростанню, як наведено нижче:

```c#
DeliveryTruck t when t.GrossWeightClass switch
{
    < 3000 => 10.00m - 2.00m,
    >= 3000 and <= 5000 => 10.00m,
    > 5000 => 10.00m + 5.00m,
},
```
Середній вираз тут використовує `and`, щоб поєднати два шаблони порівняння в єдиний шаблон, що відображає діапазон. 

Шаблон `not` може використовуватись спільно з констатним шаблоном `null`, як `not null`. Для прикладу, ми можемо розділити обробку невідомого випадку в залежності від того, чи дорівнює він `null`:

```c#
not null => throw new ArgumentException($"Not a known vehicle type: {vehicle}", nameof(vehicle)),
null => throw new ArgumentNullException(nameof(vehicle))
```
Також `not` може бути корисним з оператором if, умова якого містить вираз `is` замість потворних подвійних дужок:

```c#
if (!(e is Customer)) { ... }
```

Ви можете просто написати

```c#
if (e is not Customer) { ... }
```

## Вдосконалене приведення до цільового типу

"Приведенням до цільового типу" ми називаємо ситуацію, коли вираз отримує свій тип з контексту, в якому він використовується. Для прикладу `null` чи лямбда-вирази завжди використовують приведення до цільового типу.

В C# 9.0 деякі вирази, які до цього не використовували приведення до цільового типу, отримали можливість визначати тип з контексту.

### Приведення у виразі `new`
Вираз `new` у C# завжди вимагав вказування типу (за винятком неявно типізованих масивів). Тепер ви можете пропустити тип, якщо змінна якій присвоюється вираз вже його має. 

```c#
Point p = new (3, 5);
```

### Приведення у виразах `??` та `?:`
Інколи умовні вирази `??` та `?:` не мають явного спільного типу між різними гілками виконання. Такі випадки зараз не компілюються, але C# 9.0 буде дозволяти їх, якщо існує цільовий тип, до якого обидва результати можуть бути приведені.

```c#
Person person = student ?? customer; // спільний базовий тип
int? result = b ? 0 : null; // значимий nullable тип
```

## Коваріативні результати

Інколи корисно якось виразити те, що перевизначений метод похідного класу повертає більш конкретний тип, ніж визначено у базовому класі. C# 9.0 дозволяє таке:

```c#
abstract class Animal
{
    public abstract Food GetFood();
    ...
}
class Tiger : Animal
{
    public override Meat GetFood() => ...;
}
```

## І навіть більше…

Найкраще місце, щоб ознайомитися з повним переліком майбутніх можливостей в C# 9.0 і слідкувати за їх реалізацією - це сторінка [Статус Можливостей Мови](https://github.com/dotnet/roslyn/blob/master/docs/Language%20Feature%20Status.md) в репозиnорії Roslyn (C#/VB Compiler) на GitHub.

Приємного кодування!