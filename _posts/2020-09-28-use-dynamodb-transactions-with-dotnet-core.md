---
layout: post
published: false
title:  "Транзакції в NoSQL. Погляд на DynamoDB з позиції C#"
date:   2020-09-28 23:00:00 +0200
date_friendly: 28 вересня 2020 р. 
categories: [Програмування, dotNET]
tags: [dotnet, DynamoDB, AWS, NoSQL, transactions, ACID]
---

# NoSQL проти SQL

На протязі багатьох років в розробці програм домінували реляційні бази даних. SQL став однією з найпоширеніших мов програмування, а інженери що знали як правильно спроектувати і підтримувати роботу таких БД відокремились в окрему касту, що називається адміністратори БД або DBA. Після років розвитку SQL бази даних стали надійним інструментом при реалізації найрізноманітнішого роду програм, які вимагали узгодженості даних. Це стало можливим завдяки транзакціям, тригерам та об'єднанню даних (join) на рівні БД. Але на початку 20 століття розвиток WEB 2.0 і потреби таких компаній як Google, Facebook і Amazon спричинили революцію в збереженні даних. Сувора узгодженість і можливості внутрішнього об'єднання відступили під вимогами високої доступності, швидкості та горизонтального масштабування. З'явились такі СУБД як Neo4j, Memcached, Redis, MongoDB, Cassandra і Amazon DynamoDB. Вони призначались для збереження не структурованих даних в кластерних системах і сувора узгодженість тут не завжди була потрібна. З часом сформувалась стійка думка, що NoSQL бази даних - це для не впорядкованих даних великих розмірів, що необхідно розподіляти по багатьох серверах і швидко знаходити за примітивними запитами типу первісного ключа. В той час як SQL - це для структурованих даних, які містять відношення і повинні бути суворо узгодженими завдяки механізму транзакцій. Таке розділення способів зберігання даних призвело до породження специфічних підходів до проектування різних програмних систем. Програмісту чи архітектору перед тим як намалювати схему системи і включити в неї ту чи іншу БД необхідно було вирішити чи потрібна підсистемі зберігання даних сувора узгодженість. Що важливіше - ACID чи висока доступність та швидкість роботи з даними? Така ситуація тривала деякий час, аж поки в NoSQL базах даних не почали впроваджувати транзакції. 

В цій статті я розкажу як транзакції реалізовані в одній з перших NoSQL баз даних - Amazon DynamoDB, чим вони відрізняються від транзакцій в SQL, в яких випадках варто будувати програми з їх використанням та покажу як практично працювати з транзакціями в DynamoDB за допомогою C# та .NET Core.

# DynamoDB

Для початку познайомимось з деякими концептами цієї бази даних. DynamoDB - документна база даних, що позбавлена схеми. Вона зберігає дані в таблицях, кожна з яких може розміщуватись на декількох серверах розподіляючи навантаження. Це дозволяє DynamoDB оброблят мільйони запитів за секунду в пікові періоди і масштабуватись практично необмежено.

Для представлення документів DynamoDB використовує формат JSON. Створення таблиці вимагає лише трьох аргументів: імені таблиці, ключа та списку атрибутів, серед яких повинні бути атрибут, що використовується як ключ секції. Ключ секції (Partition Key) через застосування до нього функції гешування використовується для визначення фізичного розміщення запису. Ключ секції разом з необов'язковим ключем сортування (Sort Key або Range Key) створюють первісний ключ, що дозволяє унцікально ідентицікувати запис в таблиці DynamoDB.

Тоді як реляційні бази даних пропонують досить потужну мову запитів SQL, DynamoDB пропонує лише операції Put, Get, Update та Delete на одиночних таблицях і не пропонує об'єднань таблиць в запитах. Через цю простоту DynamoDB дуже добре масштабується і має практично необмежену пропускну здатність. 

Ще однією особливістю БД є те, що її використання тарифікується не за місцем, яке займають дані, а за пропускною здатністю, що вимірюється так званими RCU та WCU. RCU (read capacity unit) - це одиниця читання, що відповідає одному запиту на читання до 4 Kb даних. WCU (write capacity unit) - аналогічно працює на запис, тільки ліміт даних для одного WCU - 1 Kb.

Давайте спробуємо запустити DynamoDB локально і виконати прості запити на читання і запис даних.

Для роботи нам знадобляться Docker, .NET Core SDK, командний рядок та редактор коду, наприклад VSCode. Amazon пропонує локальну версію DynamoDB, яка повністю підтримує транзакції і нам цього достатньо. Тому акаунт AWS нам не потрібен, ми все будемо тестувати локально.

Відкриємо консоль і запустимо команду:

```powershell
> docker run -p 8000:8000 amazon/dynamodb-local

Unable to find image 'amazon/dynamodb-local:latest' locally
latest: Pulling from amazon/dynamodb-local
638b75f800bf: Pull complete
55cf0fc324c7: Pull complete
42245f4d852b: Pull complete
Digest: sha256:7d2178aa20b7a87a05af38cad98b06eedab9dcd4842c8d5290959e4732e63bf2
Status: Downloaded newer image for amazon/dynamodb-local:latest
Initializing DynamoDB Local with the following configuration:
Port:   8000
InMemory:       true
DbPath: null
SharedDb:       false
shouldDelayTransientStatuses:   false
CorsParams:     *
```

Docker завантжив образ dynamodb-local і запустив сервіс на порту 8000. Тепер ми можемо звернутись до бази даних за адресою localhost:8000. Дані будуть збережені в пам'яті, про що свідчить параметр InMemory: true, тому DbPath (шлях до файлу даних) порожній. Якщо ви бажаєте зберігати дані на диску між запусками контейнеру вам необхідно вказати параметри -sharedDB та -dbPath. [Детальніше](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.UsageNotes.html)

Спробуймо створити першу таблицю, але спочатку давайте опишемо нашу предметну область, що саме ми будемо програмувати.

# Система замовлення таксі

Нехай у нас є система резервування таксі. Є клієнт, водій і замовлення. Опишемо деякі вимоги до нашої системи.

1. Клієнт замовляє подорож, створюючи замовлення.
2. Водій автомобіля приймає замовлення до роботи.
3. Після доставки клієнта водій позначає замовлення виконаним.
4. Водій не може прийняти замовлення, яке вже в роботі.
5. Клієнт не може замовити більше однієї подорожі одночасно.

Це дуже спрощена схема роботи таких сервісів, як Uber або Uklon. Звісно, можна придумати набагато більше вимог до такої системи, але для нас зараз вони не важливі. Нам важливо продемонструвати ідемпотентність, узгодженність та атомарність операцій та як це може бути реалізованим з DynamoDB. Отже, які таблиці нам знадобляться в базі даних?

Нам потрібний клієнт. Так як таблиця Client повинна містити унікальний ключ, нехай це буде телефонний номер клієнта. Також таблиця клієнту буде містити поточне замовлення цього клієнту. Якщо поле замовлення порожнє - замовлень немає.

|Client|
|------|
|Id    |
|Order |

У водія все схоже, тільки для ідентифікації його давайте візьмемо номер машини.

|Driver|
|------|
|Id    |
|Order |

В таблиці Order ми будемо зберігати дані клієнта, водія, що виконує замовлення і статус замовлення: Pending, InProgress, Done

|Order|
|------|
|Id    |
|Client|
|Driver|
|Status|

