---
layout: post
published: true
title:  "Транзакції в DynamoDB"
date:   2020-09-28 23:00:00 +0200
date_friendly: 28 вересня 2020 р. 
categories: [Програмування, dotNET]
tags: [dotnet, DynamoDB, AWS, NoSQL, transaction, ACID]
---

На протязі багатьох років в розробці програмного забезпечення домінували реляційні бази даних. SQL стала однією з найпоширеніших мов програмування не в останню чергу завдяки транзакціям, тригерам та об'єднанню даних (join) на рівні БД. Але на початку 20 століття розвиток WEB 2.0 і потреби таких компаній як Google і Facebook спричинили революцію в збереженні даних. Сувора узгодженість і можливості внутрішнього об'єднання відступили під вимогами високої доступності, швидкості та горизонтального масштабування. Вони призначались для збереження не структурованих даних в кластерних системах і сувора узгодженість тут не завжди була потрібна. З часом сформувалась стійка думка, що NoSQL бази даних - це для не впорядкованих даних великих розмірів, що необхідно розподіляти по багатьох серверах і швидко знаходити за простими запитами на основі ключа. В той час як SQL - це для структурованих даних, які пов'язані відношеннями і повинні бути суворо узгодженими завдяки механізму транзакцій. Перед проектування систем програмісти почали себе запитувати: що важливіше - ACID чи висока доступність та швидкість роботи? Така ситуація тривала деякий час, аж поки в NoSQL базах даних не з'явились транзакції. 

В цій статті я розкажу про транзакції в одній з перших NoSQL баз даних - Amazon DynamoDB. Подивимось чим вони відрізняються від транзакцій в SQL, в яких випадках варто будувати програми з їх використанням і як працювати з ними за допомогою C# та .NET Core.

# DynamoDB

Для початку познайомимось з деякими концептами цієї бази даних. DynamoDB - документна база даних без схеми. Вона зберігає дані в таблицях, кожна з яких може розміщуватись на декількох серверах, розподіляючи таким чином навантаження. Це дозволяє DynamoDB оброблят мільйони запитів за секунду в пікові періоди і масштабуватись практично необмежено.

Для представлення документів DynamoDB використовує формат JSON. Створення таблиці вимагає лише трьох аргументів: імені таблиці, ключа та списку атрибутів, серед яких повинен бути атрибут, що використовується як ключ секції. Ключ секції (Partition Key) використовується для визначення фізичного розміщення запису. Ключ секції разом з необов'язковим ключем сортування (Sort Key) створюють первісний ключ, що дозволяє унікально ідентифікувати запис в таблиці DynamoDB.

![](http://www.martyniuk.info/assets/img/posts/2020-09-28-use-dynamodb-transactions-with-dotnet-core/dynamodb-table.jpg)

Тоді як реляційні бази даних пропонують досить потужну мову запитів SQL, DynamoDB пропонує лише операції Put, Get, Update та Delete на одиночних таблицях і взагалі не пропонує будь яких об'єднань таблиць. Через цю простоту DynamoDB дуже добре масштабується і має високу пропускну здатність. 

Ще однією особливістю БД є те, що її використання тарифікується не за місцем, яке займають дані, а за пропускною здатністю, що вимірюється так званими `RCU` та `WCU`. `RCU` (read capacity unit) - це одиниця, що відповідає одному запиту на читання до 4 Kb даних. `WCU` (write capacity unit) - аналогічно для запису, тільки ліміт даних для одного WCU 1 Kb.

# Локальний сервіс
Давайте спробуємо запустити DynamoDB локально і виконати прості запити на читання і запис даних.

Для роботи нам знадобляться [Docker](https://www.docker.com/), [.NET Core SDK](https://dotnet.microsoft.com/download), командний рядок та редактор коду. 

Amazon пропонує локальну версію DynamoDB у вигляді Docker образу. Вона повністю підтримує транзакції, тому акаунт AWS нам не потрібен - все будемо робити на локальному комп'ютері.

Відкриємо консоль і запустимо DynamoDB:

```powershell
> docker run -p 8000:8000 amazon/dynamodb-local

...
Initializing DynamoDB Local with the following configuration:
Port:   8000
InMemory:       true
DbPath: null
SharedDb:       false
shouldDelayTransientStatuses:   false
CorsParams:     *
```

Docker завантжив образ dynamodb-local і запустив сервіс на порту `8000`. Тепер ми можемо звернутись до бази даних за адресою `http://localhost:8000`. Дані будуть збережені в пам'яті, про що свідчить параметр `InMemory: true`, тому `DbPath` (шлях до файлу даних) порожній. Якщо ви бажаєте зберігати дані на диску між запусками контейнеру вам необхідно вказати параметри `-sharedDB` та `-dbPath`. [Детальніше](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.UsageNotes.html)

Перед тим як створити першу таблицю, давайте опишемо предметну область, яку ми будемо моделювати.

# Система замовлення таксі

Нехай у нас є система замовлення таксі. Є клієнт, водій і, власне, замовлення. Опишемо деякі вимоги до нашої системи.

1. Коли клієнт замовляє поїздку створюється замовлення.
2. Водій автомобіля приймає замовлення до роботи.
3. Водій не може прийняти замовлення, яке вже в роботі.
4. Водій не може прийняти замовлення, якщо він вже виконує інше замовлення.

Це дуже спрощена схема роботи таких сервісів, як Uber або Uklon. Звісно, можна придумати набагато більше вимог до такої системи, але для нас зараз вони не важливі. Нам важливо продемонструвати **ідемпотентність**, **узгодженність** та **атомарність** операцій з DynamoDB. Отже, які таблиці нам знадобляться в базі даних?

Нам потрібний клієнт. Будь яка таблиця DynamoDB повинна містити унікальний ключ, нехай це буде телефонний номер клієнта. Також таблиця буде містити поточне замовлення цього клієнту. 

![](http://www.martyniuk.info/assets/img/posts/2020-09-28-use-dynamodb-transactions-with-dotnet-core/client-table.jpg)

У водія все схоже, тільки як унікальний ідентифікатор візьмемо номер машини. Так як модель водія дуже схожа на модель клієнта, то чому б нам не записати їх в одну таблицю? 

В замовленні будуть міститись ідентифікатори водія, клієнта і статус замовлення: `Pending`, `InProgress`, `Done`.

![](http://www.martyniuk.info/assets/img/posts/2020-09-28-use-dynamodb-transactions-with-dotnet-core/taxi-table.jpg)

Уявімо, що в системі існує клієнт, водій та замовлення від клієнту, яке в знаходиться в статусі очікування.

![](http://www.martyniuk.info/assets/img/posts/2020-09-28-use-dynamodb-transactions-with-dotnet-core/taxi-table-1.jpg)

Для тих розробників, які багато працювали з SQL така універсальна таблиця, що містить все на світі може здатись дивною і не правильно. Їм відразу захочеться розділити її та провести нормалізацію. Але у світі NoSQL це абсолютно звична річ. Такі таблиці називаються *гомогенними*. DynamoDB не буде марнувати місце на диску для збереження порожніх полів записів, адже вона збергіає документи, або колекції атрибутів. В колекції атрибутів для записів клієнта та водія будуть відсутніми `ClientId`, `DriverId` та `OrderStatus`, а для замовлень буде відсутнім атрибут `OrderId`. Крім того, сам Amazon рекомендує використовувати гомогенні таблиці в DynamoDB. Їх рекомендація - [тримати пов'язані дані якомога ближче і мати якнайменше таблиць](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-general-nosql-design.html#bp-general-nosql-design-concepts). 

# AWS SDK та .NET Core
Створимо консольну програму в .NET Core та додамо пакет для роботи з DynamoDB API - `AWSSDK.DynamoDBv2`

```powershell
> dotnet new console
...
Restore succeeded.

> dotnet add package AWSSDK.DynamoDBv2
info : PackageReference for package 'AWSSDK.DynamoDBv2' version '3.5.0.22' added ...
...
```

У файлі `Program.cs` створимо клінта для роботи з локальною базою даних і додамо метод для створення таблиці:

```c#

private static readonly AmazonDynamoDBClient client =
    new AmazonDynamoDBClient(new AmazonDynamoDBConfig {ServiceURL = "http://localhost:8000"});

private static async Task CreateTable()
{
    await client.CreateTableAsync(new CreateTableRequest
    {
        TableName = "Taxi",
        AttributeDefinitions = new List<AttributeDefinition>
        {
            new AttributeDefinition
            {
                AttributeName = "Id",
                AttributeType = "S"
            }
        },
        KeySchema = new List<KeySchemaElement>
        {
            new KeySchemaElement
            {
                AttributeName = "Id",
                KeyType = "HASH"
            }
        },
        ProvisionedThroughput = new ProvisionedThroughput
        {
            ReadCapacityUnits = 5,
            WriteCapacityUnits = 5
        }
    });
}
```

Єдиним атрибутом який ми визначили є `Id` типу `String`. В схемі визначено, що поле `Id` буде ключем секції. Тако0ж обов'язково необхідно вказати максимальну пропускну здатність, щоб DynamoDB знала як правильно масштабуватись. Для нас це не суттєво, нехай буде 5 одиниць за секунду для читання і запису.

Додамо клієнта, водія та замовлення як показано в таблиці вище. Використаємо метод `PutItem`, без транзакції.

```c#
private static async Task AddClientDriverAndOrder()
{
    await client.PutItemAsync(new PutItemRequest
    {
        TableName = "Taxi",
        Item = new Dictionary<string, AttributeValue>()
        {
            { "Id", new AttributeValue { S = "0993832478" }},
            { "OrderId", new AttributeValue { S = "{3e80b07d-e2e6-4310-8fda-851296a17a10}" }}
        }
    });

    await client.PutItemAsync(new PutItemRequest
    {
        TableName = "Taxi",
        Item = new Dictionary<string, AttributeValue>()
        {
            { "Id", new AttributeValue { S = "АК9265АК" }}
        }
    });

    await client.PutItemAsync(new PutItemRequest
    {
        TableName = "Taxi",
        Item = new Dictionary<string, AttributeValue>()
        {
            { "Id", new AttributeValue { S = "{3e80b07d-e2e6-4310-8fda-851296a17a10}" }},
            { "ClientId", new AttributeValue { S = "0993832478" }},
            { "OrderStatus", new AttributeValue {S = "Pending"}}
        }
    });
}
```

# Транзакція в дії
Спробуймо реалізувати якусь більш складну операцію, наприклад, *водій бере замовлення у роботу*. Для того, щоб водій взяв замовлення нам необхідно:
* оновити рядок замовлення: 
  * записати Id водія в поле `DriverId`, якщо воно порожнє (водій не може взяти замовлення, яке вже виконується)
  * записати `InProgress` в поле `OrderStatus`, якщо воно було `Pending` (водій не може взяти замовлення в будь якому іншому статусі окрім "Очікує виконання")
* оновити рядок водія:
  * записати Id замовлення в поле `OrderId`, якщо воно порожнє (водій не може взяти одночасно два замовлення)

Тобто, кінцевий результат повинен виглядати наступним чином:

![](http://www.martyniuk.info/assets/img/posts/2020-09-28-use-dynamodb-transactions-with-dotnet-core/taxi-table-2.jpg)

Тут нам знадобиться [ACID](https://uk.wikipedia.org/wiki/ACID) транзакція, адже оновити рядок замовлення і рядок водія потрібно синхронно. Якщо будь яка з перелічених вище умов не виконається, жодних змін в базі не має відбутися. 

```c#
private static async Task Main(string[] args)
{
    await CreateTable();
    await AddClientDriverAndOrder();
    await DriverTakesOrder("{3e80b07d-e2e6-4310-8fda-851296a17a10}", "АК9265АК");
}

private static async Task DriverTakesOrder(string orderId, string driverId)
{
    await client.TransactWriteItemsAsync(new TransactWriteItemsRequest
    {
        TransactItems = new List<TransactWriteItem>
        {
            new TransactWriteItem
            {
                Update = new Update
                {
                    TableName = "Taxi",
                    Key = new Dictionary<string, AttributeValue>
                    {
                        { "Id", new AttributeValue { S = driverId }}
                    },
                    UpdateExpression = "set OrderId = :OrderId",
                    ConditionExpression = "attribute_not_exists(OrderId)",
                    ExpressionAttributeValues = new Dictionary<string, AttributeValue>()
                    {
                        {":OrderId", new AttributeValue { S = orderId}}
                    }
                }
            },
            new TransactWriteItem
            {
                Update = new Update
                {
                    TableName = "Taxi",
                    Key = new Dictionary<string, AttributeValue>
                    {
                        { "Id", new AttributeValue { S = orderId }}
                    },
                    UpdateExpression = "set DriverId = :DriverId, OrderStatus = :NewStatus",
                    ConditionExpression = "attribute_not_exists(DriverId) AND OrderStatus=:OldStatus",
                    ExpressionAttributeValues = new Dictionary<string, AttributeValue>()
                    {
                        {":DriverId", new AttributeValue { S = driverId}},
                        {":OldStatus", new AttributeValue { S = "Pending"}},
                        {":NewStatus", new AttributeValue { S = "InProgress"}}
                    }
                }
            }
        },
        ClientRequestToken = $"{orderId}_{driverId}"
    });
}
```

В цьому коді ми виконуємо транзакцію, що складається з двох записів - екземплярів `TransactWriteItem`. Якщо умова в `ConditionExpression` виконується - буде виконано вираз `UpdateExpression`. 

Для запису водія ми оновлюємо номер замовлення, якщо воно порожнє:
```c#
    UpdateExpression = "set OrderId = :OrderId",
    ConditionExpression = "attribute_not_exists(OrderId)",
```

Для запису замовлення ми оновлюємо поле водія та статус, якщо водій ще не був призначений, а статус дорівнює `Pending`:

```c#
    UpdateExpression = "set DriverId = :DriverId, OrderStatus = :NewStatus",
    ConditionExpression = "attribute_not_exists(DriverId) AND OrderStatus=:OldStatus",
```

Операція, що дозволяє водієві взяти замовлення відповідає нашим трьом вимогам:
* Вона **ідемпотентна**. Повторне виконання методу не змінить стан бази даних і не викличе помилку. За це відповідає атрибут `ClientRequestToken`, який по суті є токеном ідемпотентності. Час його життя складає 10 хвилин. Всі наступні запити до БД з тим самим `ClientRequestToken` будуть проігноровані. Це дозволяє, наприклад, водієві помилково натиснути два рази на кнопку прийняття замовлення. В результаті воно буде прийняте лише раз і помилки не буде.
* Вона **узгоджена**. Замовлення та рядок водія змінюються синхронно таким чином, що водій не може взяти замовлення в іншому статусі окрім `Pending`. В статусі `Pending` замовлення завжди буде мати пов'язаного водія.
* Вона **атомарна**. Запит або буде виконано повністю, або жодних змін до бази даних застосовуватись не буде.

# Можливі причини невдачі трназакцій
Якщо виконати даний метод але з неправильними даними (наприклад, водій намагається взяти в роботу чуже замовлення) він викличе помилку:
```c#
Amazon.DynamoDBv2.Model.TransactionCanceledException: 'Transaction cancelled, please refer cancellation reasons for specific reasons...'
```

Взагалі транзакція може бути відмінена з декількох причин:
* не виконується умова в `ConditionExpression`
* одночасно виконується інша транзакція з тим самим рядком 
* недостатня пропускна здатність (в нашому випадку це більше 5 викликів на секунду)
* недостатньо прав для виконання запиту (це не стосується локальної DynamoDB)

Що робити, коли ви отримали помилку викнання транзакції? Ви можете спробувати виконати операцію повторно. Переконайтесь, що ви встановили токен ідемпотентності в полі `ClientRequestToken`, тоді SDK може спробувати самостійно повторити запит.

Якщо ж ваша транзакція після повторних спроб не вдалась, необхідно виконати повторну спробу на рівні лоігки програми. Для цього необхідно перебудувати вихідний стан вашої програми і спробувати повторити транзакцію з новими умовами і новим бажаним кінцевим результатом. 

Для отримання нового вихідного стану вашої програми, її синхронізації з базою даних_ можна викориcтати один з трьох методів:
* `ReturnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure.ALL_OLD` - встановленя цього поля дозволяє повернути значення атрибутів, якщо умова транзакції не була виконана.
* Виконати `TransactionGetItems` - тобто, транзакційно отримати всі необхідні дані самотужки.
* Працювати з умовою, що узгодженість даних буде досягнута колись згодом, можливо після виконання повторного запиту.

# Порівняння з SQL
Транзакції DynamoDB реалізовані в рамках одного виклику API. В SQL і деяких інших NoSQL рішеннях, таких як MongoDB, транзакції реалізовані в розмовному стилі, тобто першим викликом транзакція відкривається, потім окремими викликами здійснюються модифікації даних і останнім транзакція врешті закривається. Такий розподіл координації між клієнтом і сервером накладає деякі обмеження на транзакції і робить їх реалізацію більш складною, а виконання - повільнішим. Транзакції DynamoDB працюють виключно на сервері і у клієнта немає контролю за початком транзакції, її підтвердженням або відміною.

Це робить транзакції DynamoDB дуже швидкими і розробнику не потрібно обирати між транзакційною БД і БД, яка добре масштабується горизонтально.

Також з транзакціями DynamoDB не можливі взаємні блокування, оскільки використовується оптимістичний контроль конкурентності. Завдяки цьому забезпечується низька затримка та висока доступність.

# Обмеження транзакцій
Але в транзакцій DynamoDB є ряд обмежень, які варто врахувати:
* Транзакції працюють лише в рамках одного регіону і одного акаунту AWS.
* Транзакції можуть містити до десяти елементів, тобто можна оновити або додати не більше 10 записів за раз.
* Транзакції споживають в два рази більше `RCU` або `WCU`, так як в середині використовуюється двофазний механізм. Після виконання транзакції дані зчитуються ще раз для підтвердження їх коректності. Через це транзакційні виклики будуть фінансово в два рази дорожчими для споживача.

# Висновок
Транзакції в DynamoDB допомагають розробникам:
* підтримувати коректність даних, вносячи зміни в декілька записів і таблиць одночасно;
* спрощувати бізнес логіку програм, переносячи на сервер валідацію даних;
* оновлювати дані в багатьох таблицях узгоджено.

Транзакції DynamoDB повністю підтримують ACID і в той же час можуть необмежено масштабуватись для забезпечення низької затримки та високої доступності даних.

Для .NET розробників Amazon пропонує низькорівневий SDK для доступу до DynamoDB, який повністю підтримує транзакції. Його використання дещо багатослівне і може заплутати новачка, але якщо ви плануєте працювати з великими навантаженнями на базу даних і в той же час не хочете позбавляти себе атомарності, узгодженості, ізоляції та довговічності, які гарантують транзакції, DynamoDB може бути хорошим вибором.